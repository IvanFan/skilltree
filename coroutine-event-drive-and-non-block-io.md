# Coroutine

Pros:

* 无需线程上下文切换的开销

* 无需原子操作锁即同步锁的开销  
  所谓原子操作是指不会被线程调度机制打打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何切换到另一个线程的动作。原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序是不可以被打乱的，或者割掉只执行的部分。视作整体是原子性的核心。

* 方便切换控制流，简化编程模型。

* 高并发+高扩展性+低成本：一个CPU可以支持上万个CPU，适合高并发处理

Cons:

* 无法利用多核资源：协程的本质是单个线程，他不能同时将单个CPU的多个和用上，协程需要和进程配合才能运行在多CPU上，当然我们日常所编写的绝大部分应用都没有这个必要，除非是CPU密集型应用。
* 进行阻塞操作，如IO操作时会阻塞掉整个程序。

e.g. python yield generator

Definition:

1. single thread
2. modify shared data without lock
3. user control the workflow
4. if I/O has been blocked, switch to other coroutine

# Event Drive & Async I/O

# 

通常，我们写服务器处理模型的时候，有以下几种模型：

1. 每收到一个请求，创建一个新的进程，来处理该请求
2. 每收到一个请求，创建一个新的线程，来处理该请求
3. 每收到一个请求，放入一个时间列表，让主进程通过非阻塞I/O方式来处理请求

以上几种方式各有优缺点：

* 第一种方法中，由于创建新的进程开销比较大，会导致服务器性能比较差，但是实现比较简单
* 第二种方式，由于要设计成线程的同步，有可能会死锁等问题。
* 第三种方式中，在写应用程序代码时，逻辑比前两种都复杂。

Event Drive Model:

1. has a message queue
2. add event to the queue
3. the loop will keep popping event to handle
4. event has its own function to handle the event

![](/assets/oscoroutineenevtdrive1.png)

event drive is a pattern

let's compare single thread, multi thread and event drive

![](/assets/os coroutine event drive2.png)



### 用户空间和内核空间 {#用户空间和内核空间}

现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）位4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保护用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两个部分，一部分为内核空间，一部分作为用户空间。针对linux操作系统而言，将最高的1G字节供内核使用，成为内核空间，而将较低的3G字节供个进程使用，称为用户空间。



### 进程切换 {#进程切换}

为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并回复以前挂起的某个进程的执行。这种行为称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

* 从一个进程的运行到另一个进程的运行，这个过程经过下面这些变化：
 
  1. 保存处理机上下文，包括程序计数器和其他寄存器。
  2. 更新PCB信息。
  3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
  4. 选择另一个进程执行，并更新其PCB。
  5. 更新内存管理的数据结构。
  6. 回复处理机上下文

总之就是非常消耗资源  
_注：进程控制块，是操作系统核心中的一种数据结构，主要表示进程状态。其作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位或与其他进程并发执行的进程。或者说，操作系统是根据PCB来对并发执行的进程进行控制可管理的。PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用户描述进程情况及控制进程运行所需的全部信息_

### 进程的阻塞 {#进程的阻塞}

正在执行的进程，由于期待的某些事情未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作等，则有系统自动执行阻塞原语（Block），是自己有运行状态变为阻塞状态。可见进程的阻塞是进程自身的一种阻塞行为，也因此只有处于运行状态的进程（获得CPU），才能将其转为阻塞状态。当进程进入阻塞状态，是不占CPU资源的。

### 文件描述符fd {#文件描述符fd}

文件描述符（File descriptor）是计算机科学中的一个术语。是一个用于表述指向文件的引用的抽象化概念。  
文件描述符在形式上是一个非负整数。实际上，他是一个索引值，指向内核为每一个进程所维护的该进程打开文件 的记录表。当程序大爱一个现有文件或者穿件一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往之适用于UNIX、Linux这样的操作系统。

### 缓存I/O {#缓存io}

缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区中拷贝到应用程序的地址空间。

缓存I/O的缺点：

* 数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存的开销是很大的。

## I/O模式 {#io模式}

对于一次I/O访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，他会经历两个阶段：  
1. 等待数据准备  
2. 将数据从内核拷贝到进程中

正式因为这两个阶段，linux系统产生了下面五种网路模式的方案：  
- 阻塞I/O（blocking IO）  
- 非阻塞I/O（nonblocking IO）  
- I/O多路复用（IO multiplexing）  
- 信号驱动I/O（signal driven IO）  
- 异步I/O（asynchronous IO）

注：信号驱动IO在实际中并不常用，所以下面只提及剩下的四中IO模型

